{"version":3,"sources":["../src/index.es6"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["'use strict';\n\nimport {createHmac, createHash} from 'crypto';\nimport {normalize} from 'path';\nimport {stringify} from 'querystring';\n\nconst CRLF = '\\n';\n\n/**\n * Computes the HMAC\n *\n * @param {!string} key - The key\n * @param {!string} data - The data to hash\n * @param {?string} [encoding=binary] - The encoding type (hex|binary)\n * @returns {string|buffer} - The output HMAC\n */\nfunction hmac(key, data, encoding='binary') {\n\treturn createHmac('sha256', key)\n\t\t.update(data)\n\t\t.digest(encoding);\n}\n\n/**\n * Computes the hash\n *\n * @param {!string} data - The data to hash\n * @returns {string} - The hashed output\n */\nexport function hash(data) {\n\treturn createHash('sha256')\n\t\t.update(data)\n\t\t.digest('hex');\n}\n\n/**\n * Formats a Date object to an AWS date string\n *\n * @param {!Date} date - The date\n * @returns {string} - The formatted date string\n */\nexport function formatDateTime(date) {\n\treturn date.toISOString().replace(/-|:|(\\.\\d+)/g, '');\n}\n\n/**\n * Creates the canonical request\n * https://docs.aws.amazon.com/general/latest/gr/sigv4-create-canonical-request.html\n *\n * @param {!string} httpRequestMethod - The HTTP request method (e.g. `GET` or `POST`)\n * @param {!string} canonicalURI - The canonical URI\n * @param {!string} canonicalQueryString - The canonical query string\n * @param {!string} canonicalHeaders - The canonical headers\n * @param {!string} signedHeaders - The signed headers\n * @param {!string} requestPayload - The payload of the request\n * @returns {string} - The canonical request\n */\nexport function canonicalRequest(httpRequestMethod, canonicalURI, canonicalQueryString, canonicalHeaders, signedHeaders,\n                                 requestPayload='') {\n\treturn [\n\t\thttpRequestMethod,\n\t\tcanonicalURI,\n\t\tcanonicalQueryString,\n\t\tcanonicalHeaders,\n\t\t'',\n\t\tsignedHeaders,\n\t\thash(requestPayload)\n\t].join('\\n');\n}\n\n/**\n * Creates the string to sign\n * https://docs.aws.amazon.com/general/latest/gr/sigv4-create-string-to-sign.html\n *\n * @param {!string} algorithm - The algorithm (`AWS4-HMAC-SHA256`)\n * @param {!string} requestDate - The request date (`YYYMMDDThhmmssZ`)\n * @param {!string} credentialScope - the credential scope (formatted as `YYYYMMDD/region/service/aws4_request`)\n * @param {!string} hashedCanonicalRequest\n * @returns {string} - The string to sign\n */\nexport function stringToSign(algorithm, requestDate, credentialScope, hashedCanonicalRequest) {\n\treturn [\n\t\talgorithm,\n\t\trequestDate,\n\t\tcredentialScope,\n\t\thashedCanonicalRequest\n\t].join('\\n');\n}\n\n/**\n * Calculates the signature\n * https://docs.aws.amazon.com/general/latest/gr/sigv4-calculate-signature.html\n *\n * @param {!string} secretAccessKey - The secret access key for the AWS account\n * @param {!string} date - The date in YYYYMMDD format\n * @param {!string} region - The AWS region (e.g. `us-east-1`)\n * @param {!string} service - The AWS service (e.g. `iam`)\n * @param {!string} stringToSign - The string to sign\n * @returns {string} - The signature\n */\nexport function sign(secretAccessKey, date, region, service, stringToSign) {\n\tlet signingKey = 'AWS4' + secretAccessKey;\n\n\t[\n\t\tdate,\n\t\tregion,\n\t\tservice,\n\t\t'aws4_request'\n\t].forEach(data => signingKey = hmac(signingKey, data));\n\n\treturn hmac(signingKey, stringToSign, 'hex');\n}\n\n/**\n * Creates the authorization string\n * https://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html\n *\n * @param {!string} algorithm\n * @param {!string} accessKeyId\n * @param {!string} credentialScope\n * @param {!string} signedHeaders\n * @param {!string} signature\n * @returns {string}\n */\nexport function authorization(algorithm, accessKeyId, credentialScope, signedHeaders, signature) {\n\tconst auth = {\n\t\t'Credential': accessKeyId + '/' + credentialScope,\n\t\t'SignedHeaders': signedHeaders,\n\t\t'Signature': signature\n\t};\n\n\treturn [\n\t\talgorithm,\n\t\tObject\n\t\t\t.keys(auth)\n\t\t\t.map(key => `${key}=${auth[key]}`)\n\t\t\t.join(', ')\n\t].join(' ');\n}\n\n/**\n * Creates a query string\n *\n * @param {!string} action\n * @param {!string} algorithm\n * @param {!string} accessKeyId\n * @param {!string} credentialScope\n * @param {!string} date\n * @param {!string} timeoutInterval\n * @param {!string} signedHeaders\n * @param {!string} signature\n * @returns {string}\n */\nexport function querystringify(action, algorithm, accessKeyId, credentialScope, date, timeoutInterval, signedHeaders,\n                               signature) {\n\treturn action + stringify({\n\t\t'X-Amz-Algorithm': algorithm,\n\t\t'X-Amz-Credential': `${accessKeyId}/${credentialScope}`,\n\t\t'X-Amz-Date': date,\n\t\t'X-Amz-Expires': timeoutInterval,\n\t\t'X-Amz-SignedHeaders': signedHeaders,\n\t\t'X-Amz-Signature': signature\n\t});\n}\n\n/**\n * Parses an HTTP request into a header and body\n *\n * @param {!string} request\n * @returns {{head: string, body: string}}\n */\nexport function parseRequest(request) {\n\tconst [head, body] = request.split(CRLF.repeat(2));\n\n\treturn {head, body};\n}\n\n/**\n * Unparses an HTTP header and an HTTP body into an HTTP request\n *\n * @param {!string} head\n * @param {string} body\n * @returns {string}\n */\nfunction unparseRequest(head, body='') {\n\treturn `${head}${CRLF.repeat(2)}${body}`\n\t\t.trim();\n}\n\n/**\n * Parses an HTTP header into its component parts\n *\n * @param {!string} head\n * @returns {{method: string, requestURI: string, httpVersion: string, headers: Array.<string>}}\n */\nexport function parseHead(head) {\n\tconst lines = head.split(CRLF);\n\tconst requestLine = lines[0];\n\tconst headers = lines.slice(1);\n\tconst {method, requestURI, httpVersion} = parseRequestLine(requestLine);\n\n\treturn {method, requestURI, httpVersion, headers};\n}\n\n/**\n * Parses an HTTP request line into its component parts\n *\n * @param {!string} requestLine\n * @returns {{method: string, requestURI: string, httpVersion: string}}\n */\nfunction parseRequestLine(requestLine) {\n\tconst method = requestLine\n\t\t.match(/^\\s*[A-Z]+\\s/ig)[0];\n\tconst httpVersion = requestLine\n\t\t.match(/\\s+http\\/\\d+\\.\\d+$/ig)[0];\n\tconst requestURI = requestLine\n\t\t.slice(method.length, -httpVersion.length);\n\n\treturn {\n\t\tmethod: method.trim(),\n\t\trequestURI,\n\t\thttpVersion: httpVersion.trim()\n\t};\n}\n\n/**\n * Parses a URL into its canonical parts\n *\n * @param {!string} rawUrl\n * @returns {{canonicalURI: string, canonicalQueryString: string}}\n */\nfunction parseUrl(rawUrl) {\n\tconst [uri, query] = rawUrl.split(/\\?(.+)/);\n\tconst queryParams = {};\n\tlet canonicalQueryString = '';\n\n\tif (query) {\n\t\tconst splitQuery = query\n\t\t\t.replace(/\\s(.+)/, '')\n\t\t\t.split('&');\n\t\tlet correctedQuery = [];\n\n\t\tif (splitQuery.length > 1) {\n\t\t\tfor (let i = 0; i < splitQuery.length; i++) {\n\t\t\t\tcorrectedQuery.push(splitQuery[i] + (~splitQuery[i].indexOf('=') ? '' : '&' + splitQuery[++i]));\n\t\t\t}\n\t\t} else {\n\t\t\tcorrectedQuery = splitQuery;\n\t\t}\n\n\t\tcorrectedQuery.forEach(param => {\n\t\t\tconst [name, val] = param.split('=');\n\n\t\t\tif (name in queryParams) {\n\t\t\t\tqueryParams[name].push(val);\n\t\t\t} else {\n\t\t\t\tqueryParams[name] = [val];\n\t\t\t}\n\t\t});\n\n\t\tlet queryParamsList = Object\n\t\t\t.keys(queryParams)\n\t\t\t.sort();\n\n\t\tcanonicalQueryString = queryParamsList\n\t\t\t.map(key => queryParams[key]\n\t\t\t\t.sort()\n\t\t\t\t.map(val => `${encodeURIComponent(key)}=${encodeURIComponent(val || '')}`)\n\t\t\t\t.join('&')\n\t\t\t)\n\t\t\t.join('&');\n\t}\n\n\tconst canonicalURI = encodeURIComponent(normalize(uri))\n\t\t.replace(/%2F/g, '/');\n\n\treturn {\n\t\tcanonicalURI,\n\t\tcanonicalQueryString\n\t};\n}\n\n/**\n * Parses raw headers into canonical headers and signed headers\n *\n * @param {Array<string>} rawHeaders\n * @returns {{canonicalHeadersString: string, signedHeadersString: string}}\n */\nfunction parseCanonicalHeaders(rawHeaders) {\n\tconst headersMap = {};\n\tlet lastHeaderName;\n\n\trawHeaders.forEach(header => {\n\t\tlet [name, value] = header\n\t\t\t.split(/:(.+)/)\n\t\t\t.slice(0, 2);\n\n\t\tif (value) {\n\t\t\tname = name.toLowerCase();\n\t\t\tlastHeaderName = name;\n\t\t} else {\n\t\t\tname = lastHeaderName;\n\t\t\tvalue = header;\n\t\t}\n\n\t\tvalue = value\n\t\t\t.replace(/\\s+/g, ' ')\n\t\t\t.trim();\n\n\t\tif (name in headersMap) {\n\t\t\theadersMap[name].push(value);\n\t\t} else {\n\t\t\theadersMap[name] = [value];\n\t\t}\n\t});\n\n\tconst signedHeadersList = Object\n\t\t.keys(headersMap)\n\t\t.sort();\n\n\tconst canonicalHeadersString = signedHeadersList\n\t\t.map(key => `${key}:${headersMap[key].join(',')}`)\n\t\t.join('\\n');\n\n\tconst signedHeadersString = signedHeadersList.join(';');\n\n\treturn {canonicalHeadersString, signedHeadersString};\n}\n\n/**\n * Adds the authorization headers, and optionally, the STS security token to the request\n *\n * @param {!string} request\n * @param {!string} authorization\n * @param {!string} [securityToken]\n * @returns {string}\n */\nexport function addAuthorization(request, authorization, securityToken) {\n\tconst parsedRequest = parseRequest(request);\n\tconst tokenLine = securityToken ? `${CRLF}X-Amz-Security-Token:${securityToken}` : '';\n\tconst authorizationLine =`${CRLF}Authorization: ${authorization}`;\n\n\treturn unparseRequest(\n\t\t`${parsedRequest.head}${tokenLine}${authorizationLine}`,\n\t\tparsedRequest.body\n\t);\n}\n\n/**\n * Creates a canonical request from a standard request\n *\n * @param {!string} request\n * @returns {string}\n */\nexport function requestToCanonicalRequest(request) {\n\tconst parsedRequest = parseRequest(request);\n\tconst parsedHead = parseHead(parsedRequest.head);\n\tconst parsedUrl = parseUrl(parsedHead.requestURI);\n\tconst parsedHeaders = parseCanonicalHeaders(parsedHead.headers);\n\n\treturn canonicalRequest(\n\t\tparsedHead.method,\n\t\tparsedUrl.canonicalURI,\n\t\tparsedUrl.canonicalQueryString,\n\t\tparsedHeaders.canonicalHeadersString,\n\t\tparsedHeaders.signedHeadersString,\n\t\tparsedRequest.body\n\t);\n}"]}