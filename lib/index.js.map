{"version":3,"sources":["../src/index.es6"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["'use strict';\n\nimport {createHmac, createHash} from 'crypto';\nimport {normalize} from 'path';\nimport {stringify} from 'querystring';\n\nconst CRLF = '\\n';\n\n/**\n * Computes the HMAC\n *\n * @param {!string} key - The key\n * @param {!string} data - The data to hash\n * @param {?string} [encoding=binary] - The encoding type (hex|binary)\n * @returns {string|buffer} - The output HMAC\n */\nfunction hmac(key, data, encoding='binary') {\n\treturn createHmac('sha256', key)\n\t\t.update(data)\n\t\t.digest(encoding);\n}\n\n/**\n * Computes the hash\n *\n * @param {!string} data - The data to hash\n * @returns {string} - The hashed output\n */\nexport function hash(data) {\n\treturn createHash('sha256')\n\t\t.update(data)\n\t\t.digest('hex');\n}\n\n/**\n * Formats a Date object to an AWS date string\n *\n * @param {!Date} date - The date\n * @returns {string} - The formatted date string\n */\nexport function formatDateTime(date) {\n\treturn date.toISOString().replace(/-|:|(\\.\\d+)/g, '');\n}\n\n/**\n * Creates the canonical request\n * https://docs.aws.amazon.com/general/latest/gr/sigv4-create-canonical-request.html\n *\n * @param {!string} httpRequestMethod - The HTTP request method (e.g. `GET` or `POST`)\n * @param {!string} canonicalURI - The canonical URI\n * @param {!string} canonicalQueryString - The canonical query string\n * @param {!string} canonicalHeaders - The canonical headers\n * @param {!string} signedHeaders - The signed headers\n * @param {!string} requestPayload - The payload of the request\n * @returns {string} - The canonical request\n */\nexport function canonicalRequest(httpRequestMethod, canonicalURI, canonicalQueryString, canonicalHeaders, signedHeaders,\n                                 requestPayload) {\n\treturn [\n\t\thttpRequestMethod,\n\t\tcanonicalURI,\n\t\tcanonicalQueryString,\n\t\tcanonicalHeaders,\n\t\t'',\n\t\tsignedHeaders,\n\t\thash(requestPayload || '')\n\t].join('\\n');\n}\n\n/**\n * Creates the string to sign\n * https://docs.aws.amazon.com/general/latest/gr/sigv4-create-string-to-sign.html\n *\n * @param {!string} algorithm - The algorithm (`AWS4-HMAC-SHA256`)\n * @param {!string} requestDate - The request date (`YYYMMDDThhmmssZ`)\n * @param {!string} credentialScope - the credential scope (formatted as `YYYYMMDD/region/service/aws4_request`)\n * @param {!string} hashedCanonicalRequest\n * @returns {string} - The string to sign\n */\nexport function stringToSign(algorithm, requestDate, credentialScope, hashedCanonicalRequest) {\n\treturn [\n\t\talgorithm,\n\t\trequestDate,\n\t\tcredentialScope,\n\t\thashedCanonicalRequest\n\t].join('\\n');\n}\n\n/**\n * Calculates the signature\n * https://docs.aws.amazon.com/general/latest/gr/sigv4-calculate-signature.html\n *\n * @param {!string} secretAccessKey - The secret access key for the AWS account\n * @param {!string} date - The date in YYYYMMDD format\n * @param {!string} region - The AWS region (e.g. `us-east-1`)\n * @param {!string} service - The AWS service (e.g. `iam`)\n * @param {!string} stringToSign - The string to sign\n * @returns {string} - The signature\n */\nexport function sign(secretAccessKey, date, region, service, stringToSign) {\n\tlet signingKey = 'AWS4' + secretAccessKey;\n\n\t[\n\t\tdate,\n\t\tregion,\n\t\tservice,\n\t\t'aws4_request'\n\t].forEach(data => signingKey = hmac(signingKey, data));\n\n\treturn hmac(signingKey, stringToSign, 'hex');\n}\n\n/**\n * Creates the authorization string\n * https://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html\n *\n * @param {!string} algorithm\n * @param {!string} accessKeyId\n * @param {!string} credentialScope\n * @param {!string} signedHeaders\n * @param {!string} signature\n * @returns {string}\n */\nexport function authorization(algorithm, accessKeyId, credentialScope, signedHeaders, signature) {\n\tlet auth = {\n\t\t'Credential': accessKeyId + '/' + credentialScope,\n\t\t'SignedHeaders': signedHeaders,\n\t\t'Signature': signature\n\t};\n\n\treturn [\n\t\talgorithm,\n\t\tObject\n\t\t\t.keys(auth)\n\t\t\t.map(key => [key, auth[key]].join('='))\n\t\t\t.join(', ')\n\t].join(' ');\n}\n\n/**\n * Creates a query string\n *\n * @param {!string} action\n * @param {!string} algorithm\n * @param {!string} accessKeyId\n * @param {!string} credentialScope\n * @param {!string} date\n * @param {!string} timeoutInterval\n * @param {!string} signedHeaders\n * @param {!string} signature\n * @returns {string}\n */\nexport function querystringify(action, algorithm, accessKeyId, credentialScope, date, timeoutInterval, signedHeaders,\n                               signature) {\n\treturn action + stringify({\n\t\t'X-Amz-Algorithm': algorithm,\n\t\t'X-Amz-Credential': accessKeyId + '/' + credentialScope,\n\t\t'X-Amz-Date': date,\n\t\t'X-Amz-Expires': timeoutInterval,\n\t\t'X-Amz-SignedHeaders': signedHeaders,\n\t\t'X-Amz-Signature': signature\n\t});\n}\n\n/**\n * Parses an HTTP request into a header and body\n *\n * @param {!string} request\n * @returns {{head: string, body: string}}\n */\nexport function parseRequest(request) {\n\tlet [head, body] = request.split(CRLF.repeat(2));\n\n\treturn {head, body};\n}\n\n/**\n * Unparses an HTTP header and an HTTP body into an HTTP request\n *\n * @param {!string} head\n * @param {string} body\n * @returns {string}\n */\nfunction unparseRequest(head, body) {\n\treturn [\n\t\thead,\n\t\tbody\n\t].join(CRLF.repeat(2)).trim();\n}\n\n/**\n * Parses an HTTP header into its component parts\n *\n * @param {!string} head\n * @returns {{method: string, requestURI: string, httpVersion: string, headers: Array.<string>}}\n */\nexport function parseHead(head) {\n\tlet lines = head.split(CRLF);\n\tlet requestLine = lines[0];\n\tlet headers = lines.slice(1);\n\tlet {method, requestURI, httpVersion} = parseRequestLine(requestLine);\n\n\treturn {method, requestURI, httpVersion, headers};\n}\n\n/**\n * Parses an HTTP request line into its component parts\n *\n * @param {!string} requestLine\n * @returns {{method: string, requestURI: string, httpVersion: string}}\n */\nfunction parseRequestLine(requestLine) {\n\tlet method = requestLine\n\t\t.match(/^\\s*[A-Z]+\\s/ig)[0];\n\tlet httpVersion = requestLine\n\t\t.match(/\\s+http\\/\\d+\\.\\d+$/ig)[0];\n\tlet requestURI = requestLine\n\t\t.slice(method.length, -httpVersion.length);\n\n\treturn {\n\t\tmethod: method.trim(),\n\t\trequestURI: requestURI,\n\t\thttpVersion: httpVersion.trim()\n\t};\n}\n\n/**\n * Parses a URL into its canonical parts\n *\n * @param {!string} rawUrl\n * @returns {{canonicalURI: string, canonicalQueryString: string}}\n */\nfunction parseUrl(rawUrl) {\n\tlet [uri, query] = rawUrl.split(/\\?(.+)/);\n\tlet queryParams = {};\n\tlet canonicalQueryString = '';\n\n\tif (query) {\n\t\tlet splitQuery = query.replace(/\\s(.+)/, '')\n\t\t\t.split('&');\n\t\tlet correctedQuery = [];\n\n\t\tif (splitQuery.length > 1) {\n\t\t\tfor (let i = 0; i < splitQuery.length; i++) {\n\t\t\t\tcorrectedQuery.push(splitQuery[i] + (~splitQuery[i].indexOf('=') ? '' : '&' + splitQuery[++i]));\n\t\t\t}\n\t\t} else {\n\t\t\tcorrectedQuery = splitQuery;\n\t\t}\n\n\t\tcorrectedQuery.forEach(param => {\n\t\t\tlet [name, val] = param.split('=');\n\n\t\t\tif (name in queryParams) {\n\t\t\t\tqueryParams[name].push(val);\n\t\t\t} else {\n\t\t\t\tqueryParams[name] = [val];\n\t\t\t}\n\t\t});\n\n\t\tlet queryParamsList = Object.keys(queryParams).sort();\n\n\t\tcanonicalQueryString = queryParamsList.map(key => {\n\t\t\treturn queryParams[key]\n\t\t\t\t.sort()\n\t\t\t\t.map(val => {\n\t\t\t\t\treturn [\n\t\t\t\t\t\tencodeURIComponent(key),\n\t\t\t\t\t\tencodeURIComponent(val || '')\n\t\t\t\t\t].join('=');\n\t\t\t\t})\n\t\t\t\t.join('&');\n\t\t}).join('&');\n\t}\n\n\treturn {\n\t\tcanonicalURI: normalize(uri),\n\t\tcanonicalQueryString\n\t};\n}\n\n/**\n * Parses raw headers into canonical headers and signed headers\n *\n * @param {string} rawHeaders\n * @returns {{canonicalHeadersString: string, signedHeadersString: string}}\n */\nfunction parseCanonicalHeaders(rawHeaders) {\n\tlet headersMap = {};\n\tlet lastHeaderName;\n\n\trawHeaders.forEach(header => {\n\t\tlet [name, value] = header.split(/:(.+)/).slice(0, 2);\n\n\t\tif (value) {\n\t\t\tname = name.toLowerCase();\n\t\t\tlastHeaderName = name;\n\t\t} else {\n\t\t\tname = lastHeaderName;\n\t\t\tvalue = header;\n\t\t}\n\n\t\tvalue = value.replace(/\\s+/g, ' ').trim();\n\n\t\tif (name in headersMap) {\n\t\t\theadersMap[name].push(value);\n\t\t} else {\n\t\t\theadersMap[name] = [value];\n\t\t}\n\t});\n\n\tlet signedHeadersList = Object.keys(headersMap).sort();\n\n\tlet canonicalHeadersString = signedHeadersList.map(key => {\n\t\treturn [\n\t\t\tkey,\n\t\t\theadersMap[key].join(',')\n\t\t].join(':');\n\t}).join('\\n');\n\n\tlet signedHeadersString = signedHeadersList.join(';');\n\n\treturn {canonicalHeadersString, signedHeadersString};\n}\n\n/**\n * Adds the authorization headers, and optionally, the STS security token to the request\n *\n * @param {!string} request\n * @param {!string} authorization\n * @param {!string} [securityToken]\n * @returns {string}\n */\nexport function addAuthorization(request, authorization, securityToken) {\n\tlet parsedRequest = parseRequest(request);\n\n\treturn unparseRequest(\n\t\t[\n\t\t\tparsedRequest.head,\n\t\t\tsecurityToken ? CRLF + 'X-Amz-Security-Token:' + securityToken : '',\n\t\t\tCRLF + 'Authorization: ' + authorization\n\t\t].join(''),\n\t\tparsedRequest.body\n\t);\n}\n\n/**\n * Creates a canonical request from a standard request\n *\n * @param {!string} request\n * @returns {string}\n */\nexport function requestToCanonicalRequest(request) {\n\tlet parsedRequest = parseRequest(request);\n\tlet parsedHead = parseHead(parsedRequest.head);\n\tlet parsedUrl = parseUrl(parsedHead.requestURI);\n\tlet parsedHeaders = parseCanonicalHeaders(parsedHead.headers);\n\n\treturn canonicalRequest(\n\t\tparsedHead.method,\n\t\tparsedUrl.canonicalURI,\n\t\tparsedUrl.canonicalQueryString,\n\t\tparsedHeaders.canonicalHeadersString,\n\t\tparsedHeaders.signedHeadersString,\n\t\tparsedRequest.body\n\t);\n}"]}